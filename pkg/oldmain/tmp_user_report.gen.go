// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package oldmain

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"migration/pkg/model"
)

func newTmpUserReport(db *gorm.DB, opts ...gen.DOOption) tmpUserReport {
	_tmpUserReport := tmpUserReport{}

	_tmpUserReport.tmpUserReportDo.UseDB(db, opts...)
	_tmpUserReport.tmpUserReportDo.UseModel(&model.TmpUserReport{})

	tableName := _tmpUserReport.tmpUserReportDo.TableName()
	_tmpUserReport.ALL = field.NewAsterisk(tableName)
	_tmpUserReport.ID = field.NewInt64(tableName, "id")
	_tmpUserReport.UID = field.NewInt32(tableName, "uid")
	_tmpUserReport.Username = field.NewString(tableName, "username")
	_tmpUserReport.SupUid1 = field.NewInt32(tableName, "sup_uid_1")
	_tmpUserReport.SupUsername1 = field.NewString(tableName, "sup_username_1")
	_tmpUserReport.SupUid2 = field.NewInt32(tableName, "sup_uid_2")
	_tmpUserReport.SupUid3 = field.NewInt32(tableName, "sup_uid_3")
	_tmpUserReport.IDPath = field.NewString(tableName, "id_path")
	_tmpUserReport.DepFirst = field.NewInt32(tableName, "dep_first")
	_tmpUserReport.DepSecond = field.NewInt32(tableName, "dep_second")
	_tmpUserReport.DepositAmount = field.NewFloat64(tableName, "deposit_amount")
	_tmpUserReport.WithdrawalAmount = field.NewFloat64(tableName, "withdrawal_amount")
	_tmpUserReport.ActivityAmount = field.NewFloat64(tableName, "activity_amount")
	_tmpUserReport.ValidStake = field.NewFloat64(tableName, "valid_stake")
	_tmpUserReport.Payout = field.NewFloat64(tableName, "payout")
	_tmpUserReport.XbProfit = field.NewFloat64(tableName, "xb_profit")
	_tmpUserReport.ProviderFee = field.NewFloat64(tableName, "provider_fee")
	_tmpUserReport.PagcorFee = field.NewFloat64(tableName, "pagcor_fee")
	_tmpUserReport.Ggr = field.NewFloat64(tableName, "ggr")
	_tmpUserReport.Ngr = field.NewFloat64(tableName, "ngr")
	_tmpUserReport.ReportDate = field.NewInt32(tableName, "report_date")

	_tmpUserReport.fillFieldMap()

	return _tmpUserReport
}

// tmpUserReport 临时用户报表
type tmpUserReport struct {
	tmpUserReportDo

	ALL              field.Asterisk
	ID               field.Int64   // id
	UID              field.Int32   // UID
	Username         field.String  // 用户名
	SupUid1          field.Int32   // 上1级代理
	SupUsername1     field.String  // 上1级代理
	SupUid2          field.Int32   // 上2级代理
	SupUid3          field.Int32   // 上3级代理
	IDPath           field.String  // 代理路径
	DepFirst         field.Int32   // 0:非首充 1:当日首充
	DepSecond        field.Int32   // 0:非二充 1:当日二充
	DepositAmount    field.Float64 // 当日充值金额
	WithdrawalAmount field.Float64 // 当日提款金额
	ActivityAmount   field.Float64 // 活动支出
	ValidStake       field.Float64 // 有效投注金额
	Payout           field.Float64 // 派彩
	XbProfit         field.Float64 // 盈亏金额
	ProviderFee      field.Float64 // 三方税收
	PagcorFee        field.Float64 // Pagcor税收
	Ggr              field.Float64 // ggr
	Ngr              field.Float64 // ngr
	ReportDate       field.Int32   // 报表日期

	fieldMap map[string]field.Expr
}

func (t tmpUserReport) Table(newTableName string) *tmpUserReport {
	t.tmpUserReportDo.UseTable(newTableName)
	return t.updateTableName(newTableName)
}

func (t tmpUserReport) As(alias string) *tmpUserReport {
	t.tmpUserReportDo.DO = *(t.tmpUserReportDo.As(alias).(*gen.DO))
	return t.updateTableName(alias)
}

func (t *tmpUserReport) updateTableName(table string) *tmpUserReport {
	t.ALL = field.NewAsterisk(table)
	t.ID = field.NewInt64(table, "id")
	t.UID = field.NewInt32(table, "uid")
	t.Username = field.NewString(table, "username")
	t.SupUid1 = field.NewInt32(table, "sup_uid_1")
	t.SupUsername1 = field.NewString(table, "sup_username_1")
	t.SupUid2 = field.NewInt32(table, "sup_uid_2")
	t.SupUid3 = field.NewInt32(table, "sup_uid_3")
	t.IDPath = field.NewString(table, "id_path")
	t.DepFirst = field.NewInt32(table, "dep_first")
	t.DepSecond = field.NewInt32(table, "dep_second")
	t.DepositAmount = field.NewFloat64(table, "deposit_amount")
	t.WithdrawalAmount = field.NewFloat64(table, "withdrawal_amount")
	t.ActivityAmount = field.NewFloat64(table, "activity_amount")
	t.ValidStake = field.NewFloat64(table, "valid_stake")
	t.Payout = field.NewFloat64(table, "payout")
	t.XbProfit = field.NewFloat64(table, "xb_profit")
	t.ProviderFee = field.NewFloat64(table, "provider_fee")
	t.PagcorFee = field.NewFloat64(table, "pagcor_fee")
	t.Ggr = field.NewFloat64(table, "ggr")
	t.Ngr = field.NewFloat64(table, "ngr")
	t.ReportDate = field.NewInt32(table, "report_date")

	t.fillFieldMap()

	return t
}

func (t *tmpUserReport) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := t.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (t *tmpUserReport) fillFieldMap() {
	t.fieldMap = make(map[string]field.Expr, 21)
	t.fieldMap["id"] = t.ID
	t.fieldMap["uid"] = t.UID
	t.fieldMap["username"] = t.Username
	t.fieldMap["sup_uid_1"] = t.SupUid1
	t.fieldMap["sup_username_1"] = t.SupUsername1
	t.fieldMap["sup_uid_2"] = t.SupUid2
	t.fieldMap["sup_uid_3"] = t.SupUid3
	t.fieldMap["id_path"] = t.IDPath
	t.fieldMap["dep_first"] = t.DepFirst
	t.fieldMap["dep_second"] = t.DepSecond
	t.fieldMap["deposit_amount"] = t.DepositAmount
	t.fieldMap["withdrawal_amount"] = t.WithdrawalAmount
	t.fieldMap["activity_amount"] = t.ActivityAmount
	t.fieldMap["valid_stake"] = t.ValidStake
	t.fieldMap["payout"] = t.Payout
	t.fieldMap["xb_profit"] = t.XbProfit
	t.fieldMap["provider_fee"] = t.ProviderFee
	t.fieldMap["pagcor_fee"] = t.PagcorFee
	t.fieldMap["ggr"] = t.Ggr
	t.fieldMap["ngr"] = t.Ngr
	t.fieldMap["report_date"] = t.ReportDate
}

func (t tmpUserReport) clone(db *gorm.DB) tmpUserReport {
	t.tmpUserReportDo.ReplaceConnPool(db.Statement.ConnPool)
	return t
}

func (t tmpUserReport) replaceDB(db *gorm.DB) tmpUserReport {
	t.tmpUserReportDo.ReplaceDB(db)
	return t
}

type tmpUserReportDo struct{ gen.DO }

func (t tmpUserReportDo) Debug() *tmpUserReportDo {
	return t.withDO(t.DO.Debug())
}

func (t tmpUserReportDo) WithContext(ctx context.Context) *tmpUserReportDo {
	return t.withDO(t.DO.WithContext(ctx))
}

func (t tmpUserReportDo) ReadDB() *tmpUserReportDo {
	return t.Clauses(dbresolver.Read)
}

func (t tmpUserReportDo) WriteDB() *tmpUserReportDo {
	return t.Clauses(dbresolver.Write)
}

func (t tmpUserReportDo) Session(config *gorm.Session) *tmpUserReportDo {
	return t.withDO(t.DO.Session(config))
}

func (t tmpUserReportDo) Clauses(conds ...clause.Expression) *tmpUserReportDo {
	return t.withDO(t.DO.Clauses(conds...))
}

func (t tmpUserReportDo) Returning(value interface{}, columns ...string) *tmpUserReportDo {
	return t.withDO(t.DO.Returning(value, columns...))
}

func (t tmpUserReportDo) Not(conds ...gen.Condition) *tmpUserReportDo {
	return t.withDO(t.DO.Not(conds...))
}

func (t tmpUserReportDo) Or(conds ...gen.Condition) *tmpUserReportDo {
	return t.withDO(t.DO.Or(conds...))
}

func (t tmpUserReportDo) Select(conds ...field.Expr) *tmpUserReportDo {
	return t.withDO(t.DO.Select(conds...))
}

func (t tmpUserReportDo) Where(conds ...gen.Condition) *tmpUserReportDo {
	return t.withDO(t.DO.Where(conds...))
}

func (t tmpUserReportDo) Order(conds ...field.Expr) *tmpUserReportDo {
	return t.withDO(t.DO.Order(conds...))
}

func (t tmpUserReportDo) Distinct(cols ...field.Expr) *tmpUserReportDo {
	return t.withDO(t.DO.Distinct(cols...))
}

func (t tmpUserReportDo) Omit(cols ...field.Expr) *tmpUserReportDo {
	return t.withDO(t.DO.Omit(cols...))
}

func (t tmpUserReportDo) Join(table schema.Tabler, on ...field.Expr) *tmpUserReportDo {
	return t.withDO(t.DO.Join(table, on...))
}

func (t tmpUserReportDo) LeftJoin(table schema.Tabler, on ...field.Expr) *tmpUserReportDo {
	return t.withDO(t.DO.LeftJoin(table, on...))
}

func (t tmpUserReportDo) RightJoin(table schema.Tabler, on ...field.Expr) *tmpUserReportDo {
	return t.withDO(t.DO.RightJoin(table, on...))
}

func (t tmpUserReportDo) Group(cols ...field.Expr) *tmpUserReportDo {
	return t.withDO(t.DO.Group(cols...))
}

func (t tmpUserReportDo) Having(conds ...gen.Condition) *tmpUserReportDo {
	return t.withDO(t.DO.Having(conds...))
}

func (t tmpUserReportDo) Limit(limit int) *tmpUserReportDo {
	return t.withDO(t.DO.Limit(limit))
}

func (t tmpUserReportDo) Offset(offset int) *tmpUserReportDo {
	return t.withDO(t.DO.Offset(offset))
}

func (t tmpUserReportDo) Scopes(funcs ...func(gen.Dao) gen.Dao) *tmpUserReportDo {
	return t.withDO(t.DO.Scopes(funcs...))
}

func (t tmpUserReportDo) Unscoped() *tmpUserReportDo {
	return t.withDO(t.DO.Unscoped())
}

func (t tmpUserReportDo) Create(values ...*model.TmpUserReport) error {
	if len(values) == 0 {
		return nil
	}
	return t.DO.Create(values)
}

func (t tmpUserReportDo) CreateInBatches(values []*model.TmpUserReport, batchSize int) error {
	return t.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (t tmpUserReportDo) Save(values ...*model.TmpUserReport) error {
	if len(values) == 0 {
		return nil
	}
	return t.DO.Save(values)
}

func (t tmpUserReportDo) First() (*model.TmpUserReport, error) {
	if result, err := t.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.TmpUserReport), nil
	}
}

func (t tmpUserReportDo) Take() (*model.TmpUserReport, error) {
	if result, err := t.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.TmpUserReport), nil
	}
}

func (t tmpUserReportDo) Last() (*model.TmpUserReport, error) {
	if result, err := t.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.TmpUserReport), nil
	}
}

func (t tmpUserReportDo) Find() ([]*model.TmpUserReport, error) {
	result, err := t.DO.Find()
	return result.([]*model.TmpUserReport), err
}

func (t tmpUserReportDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.TmpUserReport, err error) {
	buf := make([]*model.TmpUserReport, 0, batchSize)
	err = t.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (t tmpUserReportDo) FindInBatches(result *[]*model.TmpUserReport, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return t.DO.FindInBatches(result, batchSize, fc)
}

func (t tmpUserReportDo) Attrs(attrs ...field.AssignExpr) *tmpUserReportDo {
	return t.withDO(t.DO.Attrs(attrs...))
}

func (t tmpUserReportDo) Assign(attrs ...field.AssignExpr) *tmpUserReportDo {
	return t.withDO(t.DO.Assign(attrs...))
}

func (t tmpUserReportDo) Joins(fields ...field.RelationField) *tmpUserReportDo {
	for _, _f := range fields {
		t = *t.withDO(t.DO.Joins(_f))
	}
	return &t
}

func (t tmpUserReportDo) Preload(fields ...field.RelationField) *tmpUserReportDo {
	for _, _f := range fields {
		t = *t.withDO(t.DO.Preload(_f))
	}
	return &t
}

func (t tmpUserReportDo) FirstOrInit() (*model.TmpUserReport, error) {
	if result, err := t.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.TmpUserReport), nil
	}
}

func (t tmpUserReportDo) FirstOrCreate() (*model.TmpUserReport, error) {
	if result, err := t.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.TmpUserReport), nil
	}
}

func (t tmpUserReportDo) FindByPage(offset int, limit int) (result []*model.TmpUserReport, count int64, err error) {
	result, err = t.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = t.Offset(-1).Limit(-1).Count()
	return
}

func (t tmpUserReportDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = t.Count()
	if err != nil {
		return
	}

	err = t.Offset(offset).Limit(limit).Scan(result)
	return
}

func (t tmpUserReportDo) Scan(result interface{}) (err error) {
	return t.DO.Scan(result)
}

func (t tmpUserReportDo) Delete(models ...*model.TmpUserReport) (result gen.ResultInfo, err error) {
	return t.DO.Delete(models)
}

func (t *tmpUserReportDo) withDO(do gen.Dao) *tmpUserReportDo {
	t.DO = *do.(*gen.DO)
	return t
}
