// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package oldmain

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"migration/pkg/model"
)

func newActivityBase(db *gorm.DB, opts ...gen.DOOption) activityBase {
	_activityBase := activityBase{}

	_activityBase.activityBaseDo.UseDB(db, opts...)
	_activityBase.activityBaseDo.UseModel(&model.ActivityBase{})

	tableName := _activityBase.activityBaseDo.TableName()
	_activityBase.ALL = field.NewAsterisk(tableName)
	_activityBase.ID = field.NewInt64(tableName, "id")
	_activityBase.Category = field.NewInt32(tableName, "category")
	_activityBase.ActivityType = field.NewInt32(tableName, "activity_type")
	_activityBase.ActivityTitle = field.NewString(tableName, "activity_title")
	_activityBase.ActivityDescription = field.NewString(tableName, "activity_description")
	_activityBase.DepositType = field.NewInt32(tableName, "deposit_type")
	_activityBase.ActivitySort = field.NewInt32(tableName, "activity_sort")
	_activityBase.IsEnabled = field.NewInt32(tableName, "is_enabled")
	_activityBase.StartDate = field.NewInt32(tableName, "start_date")
	_activityBase.EndDate = field.NewInt32(tableName, "end_date")
	_activityBase.ActivityPlatform = field.NewString(tableName, "activity_platform")
	_activityBase.MinDepositAmount = field.NewFloat64(tableName, "min_deposit_amount")
	_activityBase.MaxDepositAmount = field.NewFloat64(tableName, "max_deposit_amount")
	_activityBase.BonusPercentage = field.NewFloat64(tableName, "bonus_percentage")
	_activityBase.MaxBonusAmount = field.NewFloat64(tableName, "max_bonus_amount")
	_activityBase.MaxActivePerson = field.NewInt32(tableName, "max_active_person")
	_activityBase.GameProviderSubtypeID = field.NewString(tableName, "game_provider_subtype_id")
	_activityBase.GameTypeID = field.NewString(tableName, "game_type_id")
	_activityBase.GameListID = field.NewString(tableName, "game_list_id")
	_activityBase.WageringRequirement = field.NewFloat64(tableName, "wagering_requirement")
	_activityBase.ActivityContent = field.NewString(tableName, "activity_content")
	_activityBase.CreateAt = field.NewInt32(tableName, "create_at")
	_activityBase.UpdateAt = field.NewInt32(tableName, "update_at")
	_activityBase.OpUser = field.NewString(tableName, "op_user")
	_activityBase.IsAllowNewJoin = field.NewInt32(tableName, "is_allow_new_join")

	_activityBase.fillFieldMap()

	return _activityBase
}

// activityBase 活动基础信息表
type activityBase struct {
	activityBaseDo

	ALL                   field.Asterisk
	ID                    field.Int64   // 活动ID，自增主键
	Category              field.Int32   // 活动类型:1-首存送、2-次存送、3-日存送、4-周存送、5-圣诞节
	ActivityType          field.Int32   // 活动分类：1-充值送，2-注册送，3-救济金，4-签到，5-特定活动
	ActivityTitle         field.String  // 活动标题
	ActivityDescription   field.String  // 活动描述
	DepositType           field.Int32   // 存款类型:0-全部、1-首存、2-次存、3-三存、4-其他存款
	ActivitySort          field.Int32   // 活动排序（0-1000）活动排序只针对活动排序内容不涉及弹窗和轮播
	IsEnabled             field.Int32   // 是否启用：1-启用，2-禁用
	StartDate             field.Int32   // 活动开始日期
	EndDate               field.Int32   // 活动结束日期
	ActivityPlatform      field.String  // 活动端多选：H5、WEB、APP
	MinDepositAmount      field.Float64 // 活动最小充值金额
	MaxDepositAmount      field.Float64 // 活动最大充值金额
	BonusPercentage       field.Float64 // 活动奖金比例
	MaxBonusAmount        field.Float64 // 最高可获奖金
	MaxActivePerson       field.Int32   // 活动名额限制
	GameProviderSubtypeID field.String  // 不能改 游戏厂商：0-全部,其他字符串逗号分隔
	GameTypeID            field.String  // 不能改 游戏类型：0-全部,其他字符串逗号分隔
	GameListID            field.String  // 不能改 子游戏类型：0-全部,其他字符串逗号分隔
	WageringRequirement   field.Float64 // 不能改 活动打码倍数
	ActivityContent       field.String  // 活动内容
	CreateAt              field.Int32   // 创建时间
	UpdateAt              field.Int32   // 修改时间
	OpUser                field.String  // 操作人
	IsAllowNewJoin        field.Int32   // 是否允许用户新参与活动:1-允许,2-不允许

	fieldMap map[string]field.Expr
}

func (a activityBase) Table(newTableName string) *activityBase {
	a.activityBaseDo.UseTable(newTableName)
	return a.updateTableName(newTableName)
}

func (a activityBase) As(alias string) *activityBase {
	a.activityBaseDo.DO = *(a.activityBaseDo.As(alias).(*gen.DO))
	return a.updateTableName(alias)
}

func (a *activityBase) updateTableName(table string) *activityBase {
	a.ALL = field.NewAsterisk(table)
	a.ID = field.NewInt64(table, "id")
	a.Category = field.NewInt32(table, "category")
	a.ActivityType = field.NewInt32(table, "activity_type")
	a.ActivityTitle = field.NewString(table, "activity_title")
	a.ActivityDescription = field.NewString(table, "activity_description")
	a.DepositType = field.NewInt32(table, "deposit_type")
	a.ActivitySort = field.NewInt32(table, "activity_sort")
	a.IsEnabled = field.NewInt32(table, "is_enabled")
	a.StartDate = field.NewInt32(table, "start_date")
	a.EndDate = field.NewInt32(table, "end_date")
	a.ActivityPlatform = field.NewString(table, "activity_platform")
	a.MinDepositAmount = field.NewFloat64(table, "min_deposit_amount")
	a.MaxDepositAmount = field.NewFloat64(table, "max_deposit_amount")
	a.BonusPercentage = field.NewFloat64(table, "bonus_percentage")
	a.MaxBonusAmount = field.NewFloat64(table, "max_bonus_amount")
	a.MaxActivePerson = field.NewInt32(table, "max_active_person")
	a.GameProviderSubtypeID = field.NewString(table, "game_provider_subtype_id")
	a.GameTypeID = field.NewString(table, "game_type_id")
	a.GameListID = field.NewString(table, "game_list_id")
	a.WageringRequirement = field.NewFloat64(table, "wagering_requirement")
	a.ActivityContent = field.NewString(table, "activity_content")
	a.CreateAt = field.NewInt32(table, "create_at")
	a.UpdateAt = field.NewInt32(table, "update_at")
	a.OpUser = field.NewString(table, "op_user")
	a.IsAllowNewJoin = field.NewInt32(table, "is_allow_new_join")

	a.fillFieldMap()

	return a
}

func (a *activityBase) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := a.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (a *activityBase) fillFieldMap() {
	a.fieldMap = make(map[string]field.Expr, 25)
	a.fieldMap["id"] = a.ID
	a.fieldMap["category"] = a.Category
	a.fieldMap["activity_type"] = a.ActivityType
	a.fieldMap["activity_title"] = a.ActivityTitle
	a.fieldMap["activity_description"] = a.ActivityDescription
	a.fieldMap["deposit_type"] = a.DepositType
	a.fieldMap["activity_sort"] = a.ActivitySort
	a.fieldMap["is_enabled"] = a.IsEnabled
	a.fieldMap["start_date"] = a.StartDate
	a.fieldMap["end_date"] = a.EndDate
	a.fieldMap["activity_platform"] = a.ActivityPlatform
	a.fieldMap["min_deposit_amount"] = a.MinDepositAmount
	a.fieldMap["max_deposit_amount"] = a.MaxDepositAmount
	a.fieldMap["bonus_percentage"] = a.BonusPercentage
	a.fieldMap["max_bonus_amount"] = a.MaxBonusAmount
	a.fieldMap["max_active_person"] = a.MaxActivePerson
	a.fieldMap["game_provider_subtype_id"] = a.GameProviderSubtypeID
	a.fieldMap["game_type_id"] = a.GameTypeID
	a.fieldMap["game_list_id"] = a.GameListID
	a.fieldMap["wagering_requirement"] = a.WageringRequirement
	a.fieldMap["activity_content"] = a.ActivityContent
	a.fieldMap["create_at"] = a.CreateAt
	a.fieldMap["update_at"] = a.UpdateAt
	a.fieldMap["op_user"] = a.OpUser
	a.fieldMap["is_allow_new_join"] = a.IsAllowNewJoin
}

func (a activityBase) clone(db *gorm.DB) activityBase {
	a.activityBaseDo.ReplaceConnPool(db.Statement.ConnPool)
	return a
}

func (a activityBase) replaceDB(db *gorm.DB) activityBase {
	a.activityBaseDo.ReplaceDB(db)
	return a
}

type activityBaseDo struct{ gen.DO }

func (a activityBaseDo) Debug() *activityBaseDo {
	return a.withDO(a.DO.Debug())
}

func (a activityBaseDo) WithContext(ctx context.Context) *activityBaseDo {
	return a.withDO(a.DO.WithContext(ctx))
}

func (a activityBaseDo) ReadDB() *activityBaseDo {
	return a.Clauses(dbresolver.Read)
}

func (a activityBaseDo) WriteDB() *activityBaseDo {
	return a.Clauses(dbresolver.Write)
}

func (a activityBaseDo) Session(config *gorm.Session) *activityBaseDo {
	return a.withDO(a.DO.Session(config))
}

func (a activityBaseDo) Clauses(conds ...clause.Expression) *activityBaseDo {
	return a.withDO(a.DO.Clauses(conds...))
}

func (a activityBaseDo) Returning(value interface{}, columns ...string) *activityBaseDo {
	return a.withDO(a.DO.Returning(value, columns...))
}

func (a activityBaseDo) Not(conds ...gen.Condition) *activityBaseDo {
	return a.withDO(a.DO.Not(conds...))
}

func (a activityBaseDo) Or(conds ...gen.Condition) *activityBaseDo {
	return a.withDO(a.DO.Or(conds...))
}

func (a activityBaseDo) Select(conds ...field.Expr) *activityBaseDo {
	return a.withDO(a.DO.Select(conds...))
}

func (a activityBaseDo) Where(conds ...gen.Condition) *activityBaseDo {
	return a.withDO(a.DO.Where(conds...))
}

func (a activityBaseDo) Order(conds ...field.Expr) *activityBaseDo {
	return a.withDO(a.DO.Order(conds...))
}

func (a activityBaseDo) Distinct(cols ...field.Expr) *activityBaseDo {
	return a.withDO(a.DO.Distinct(cols...))
}

func (a activityBaseDo) Omit(cols ...field.Expr) *activityBaseDo {
	return a.withDO(a.DO.Omit(cols...))
}

func (a activityBaseDo) Join(table schema.Tabler, on ...field.Expr) *activityBaseDo {
	return a.withDO(a.DO.Join(table, on...))
}

func (a activityBaseDo) LeftJoin(table schema.Tabler, on ...field.Expr) *activityBaseDo {
	return a.withDO(a.DO.LeftJoin(table, on...))
}

func (a activityBaseDo) RightJoin(table schema.Tabler, on ...field.Expr) *activityBaseDo {
	return a.withDO(a.DO.RightJoin(table, on...))
}

func (a activityBaseDo) Group(cols ...field.Expr) *activityBaseDo {
	return a.withDO(a.DO.Group(cols...))
}

func (a activityBaseDo) Having(conds ...gen.Condition) *activityBaseDo {
	return a.withDO(a.DO.Having(conds...))
}

func (a activityBaseDo) Limit(limit int) *activityBaseDo {
	return a.withDO(a.DO.Limit(limit))
}

func (a activityBaseDo) Offset(offset int) *activityBaseDo {
	return a.withDO(a.DO.Offset(offset))
}

func (a activityBaseDo) Scopes(funcs ...func(gen.Dao) gen.Dao) *activityBaseDo {
	return a.withDO(a.DO.Scopes(funcs...))
}

func (a activityBaseDo) Unscoped() *activityBaseDo {
	return a.withDO(a.DO.Unscoped())
}

func (a activityBaseDo) Create(values ...*model.ActivityBase) error {
	if len(values) == 0 {
		return nil
	}
	return a.DO.Create(values)
}

func (a activityBaseDo) CreateInBatches(values []*model.ActivityBase, batchSize int) error {
	return a.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (a activityBaseDo) Save(values ...*model.ActivityBase) error {
	if len(values) == 0 {
		return nil
	}
	return a.DO.Save(values)
}

func (a activityBaseDo) First() (*model.ActivityBase, error) {
	if result, err := a.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.ActivityBase), nil
	}
}

func (a activityBaseDo) Take() (*model.ActivityBase, error) {
	if result, err := a.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.ActivityBase), nil
	}
}

func (a activityBaseDo) Last() (*model.ActivityBase, error) {
	if result, err := a.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.ActivityBase), nil
	}
}

func (a activityBaseDo) Find() ([]*model.ActivityBase, error) {
	result, err := a.DO.Find()
	return result.([]*model.ActivityBase), err
}

func (a activityBaseDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.ActivityBase, err error) {
	buf := make([]*model.ActivityBase, 0, batchSize)
	err = a.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (a activityBaseDo) FindInBatches(result *[]*model.ActivityBase, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return a.DO.FindInBatches(result, batchSize, fc)
}

func (a activityBaseDo) Attrs(attrs ...field.AssignExpr) *activityBaseDo {
	return a.withDO(a.DO.Attrs(attrs...))
}

func (a activityBaseDo) Assign(attrs ...field.AssignExpr) *activityBaseDo {
	return a.withDO(a.DO.Assign(attrs...))
}

func (a activityBaseDo) Joins(fields ...field.RelationField) *activityBaseDo {
	for _, _f := range fields {
		a = *a.withDO(a.DO.Joins(_f))
	}
	return &a
}

func (a activityBaseDo) Preload(fields ...field.RelationField) *activityBaseDo {
	for _, _f := range fields {
		a = *a.withDO(a.DO.Preload(_f))
	}
	return &a
}

func (a activityBaseDo) FirstOrInit() (*model.ActivityBase, error) {
	if result, err := a.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.ActivityBase), nil
	}
}

func (a activityBaseDo) FirstOrCreate() (*model.ActivityBase, error) {
	if result, err := a.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.ActivityBase), nil
	}
}

func (a activityBaseDo) FindByPage(offset int, limit int) (result []*model.ActivityBase, count int64, err error) {
	result, err = a.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = a.Offset(-1).Limit(-1).Count()
	return
}

func (a activityBaseDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = a.Count()
	if err != nil {
		return
	}

	err = a.Offset(offset).Limit(limit).Scan(result)
	return
}

func (a activityBaseDo) Scan(result interface{}) (err error) {
	return a.DO.Scan(result)
}

func (a activityBaseDo) Delete(models ...*model.ActivityBase) (result gen.ResultInfo, err error) {
	return a.DO.Delete(models)
}

func (a *activityBaseDo) withDO(do gen.Dao) *activityBaseDo {
	a.DO = *do.(*gen.DO)
	return a
}
