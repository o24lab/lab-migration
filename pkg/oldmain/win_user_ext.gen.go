// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package oldmain

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"migration/pkg/model"
)

func newWinUserExt(db *gorm.DB, opts ...gen.DOOption) winUserExt {
	_winUserExt := winUserExt{}

	_winUserExt.winUserExtDo.UseDB(db, opts...)
	_winUserExt.winUserExtDo.UseModel(&model.WinUserExt{})

	tableName := _winUserExt.winUserExtDo.TableName()
	_winUserExt.ALL = field.NewAsterisk(tableName)
	_winUserExt.ID = field.NewInt32(tableName, "id")
	_winUserExt.Username = field.NewString(tableName, "username")
	_winUserExt.AgentLevel = field.NewInt32(tableName, "agent_level")
	_winUserExt.AgentPath = field.NewString(tableName, "agent_path")
	_winUserExt.TeamCount = field.NewInt32(tableName, "team_count")
	_winUserExt.TeamDirectCount = field.NewInt32(tableName, "team_direct_count")
	_winUserExt.LevelID = field.NewInt32(tableName, "level_id")
	_winUserExt.LevelMax = field.NewInt32(tableName, "level_max")
	_winUserExt.LevelBet = field.NewFloat64(tableName, "level_bet")
	_winUserExt.LevelDeposit = field.NewFloat64(tableName, "level_deposit")
	_winUserExt.LevelChangeAt = field.NewInt32(tableName, "level_change_at")
	_winUserExt.TotalDeposit = field.NewFloat64(tableName, "total_deposit")
	_winUserExt.TotalAdminTransfer = field.NewFloat64(tableName, "total_admin_transfer")
	_winUserExt.TotalAdminTransferSub = field.NewFloat64(tableName, "total_admin_transfer_sub")
	_winUserExt.TotalAdminTransferAdd = field.NewFloat64(tableName, "total_admin_transfer_add")
	_winUserExt.TotalBet = field.NewFloat64(tableName, "total_bet")
	_winUserExt.TotalValidBet = field.NewFloat64(tableName, "total_valid_bet")
	_winUserExt.TotalWithdrawal = field.NewFloat64(tableName, "total_withdrawal")
	_winUserExt.WithdrawalNum = field.NewInt32(tableName, "withdrawal_num")
	_winUserExt.DepositNum = field.NewInt32(tableName, "deposit_num")
	_winUserExt.WithdrawalMustCode = field.NewFloat64(tableName, "withdrawal_must_code")
	_winUserExt.WithdrawalMustRealCode = field.NewFloat64(tableName, "withdrawal_must_real_code")
	_winUserExt.CreatedAt = field.NewInt32(tableName, "created_at")
	_winUserExt.UpdatedAt = field.NewInt32(tableName, "updated_at")

	_winUserExt.fillFieldMap()

	return _winUserExt
}

// winUserExt 用户扩展信息
type winUserExt struct {
	winUserExtDo

	ALL                    field.Asterisk
	ID                     field.Int32   // 用户ID
	Username               field.String  // 用户名
	AgentLevel             field.Int32   // 代理等级
	AgentPath              field.String  // 代理详细路径-分割
	TeamCount              field.Int32   // 团队总人数
	TeamDirectCount        field.Int32   // 团队直属人
	LevelID                field.Int32   // 会员等级
	LevelMax               field.Int32   // 用户达到最高等级
	LevelBet               field.Float64 // vip等级投注总额
	LevelDeposit           field.Float64 // vip等级充值总额
	LevelChangeAt          field.Int32   // 等级变更时间
	TotalDeposit           field.Float64 // 充值总额
	TotalAdminTransfer     field.Float64 // 调账总额绝对值
	TotalAdminTransferSub  field.Float64 // 调账总额减
	TotalAdminTransferAdd  field.Float64 // 调账总额加
	TotalBet               field.Float64 // 投注总额
	TotalValidBet          field.Float64 // 有效投注总额
	TotalWithdrawal        field.Float64 // 提款总额
	WithdrawalNum          field.Int32   // 提款次数
	DepositNum             field.Int32   // 充值次数
	WithdrawalMustCode     field.Float64 // 下次提现所需打码量
	WithdrawalMustRealCode field.Float64 // 下次提现实际打码量
	CreatedAt              field.Int32   // 创建时间
	UpdatedAt              field.Int32   // 修改时间

	fieldMap map[string]field.Expr
}

func (w winUserExt) Table(newTableName string) *winUserExt {
	w.winUserExtDo.UseTable(newTableName)
	return w.updateTableName(newTableName)
}

func (w winUserExt) As(alias string) *winUserExt {
	w.winUserExtDo.DO = *(w.winUserExtDo.As(alias).(*gen.DO))
	return w.updateTableName(alias)
}

func (w *winUserExt) updateTableName(table string) *winUserExt {
	w.ALL = field.NewAsterisk(table)
	w.ID = field.NewInt32(table, "id")
	w.Username = field.NewString(table, "username")
	w.AgentLevel = field.NewInt32(table, "agent_level")
	w.AgentPath = field.NewString(table, "agent_path")
	w.TeamCount = field.NewInt32(table, "team_count")
	w.TeamDirectCount = field.NewInt32(table, "team_direct_count")
	w.LevelID = field.NewInt32(table, "level_id")
	w.LevelMax = field.NewInt32(table, "level_max")
	w.LevelBet = field.NewFloat64(table, "level_bet")
	w.LevelDeposit = field.NewFloat64(table, "level_deposit")
	w.LevelChangeAt = field.NewInt32(table, "level_change_at")
	w.TotalDeposit = field.NewFloat64(table, "total_deposit")
	w.TotalAdminTransfer = field.NewFloat64(table, "total_admin_transfer")
	w.TotalAdminTransferSub = field.NewFloat64(table, "total_admin_transfer_sub")
	w.TotalAdminTransferAdd = field.NewFloat64(table, "total_admin_transfer_add")
	w.TotalBet = field.NewFloat64(table, "total_bet")
	w.TotalValidBet = field.NewFloat64(table, "total_valid_bet")
	w.TotalWithdrawal = field.NewFloat64(table, "total_withdrawal")
	w.WithdrawalNum = field.NewInt32(table, "withdrawal_num")
	w.DepositNum = field.NewInt32(table, "deposit_num")
	w.WithdrawalMustCode = field.NewFloat64(table, "withdrawal_must_code")
	w.WithdrawalMustRealCode = field.NewFloat64(table, "withdrawal_must_real_code")
	w.CreatedAt = field.NewInt32(table, "created_at")
	w.UpdatedAt = field.NewInt32(table, "updated_at")

	w.fillFieldMap()

	return w
}

func (w *winUserExt) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := w.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (w *winUserExt) fillFieldMap() {
	w.fieldMap = make(map[string]field.Expr, 24)
	w.fieldMap["id"] = w.ID
	w.fieldMap["username"] = w.Username
	w.fieldMap["agent_level"] = w.AgentLevel
	w.fieldMap["agent_path"] = w.AgentPath
	w.fieldMap["team_count"] = w.TeamCount
	w.fieldMap["team_direct_count"] = w.TeamDirectCount
	w.fieldMap["level_id"] = w.LevelID
	w.fieldMap["level_max"] = w.LevelMax
	w.fieldMap["level_bet"] = w.LevelBet
	w.fieldMap["level_deposit"] = w.LevelDeposit
	w.fieldMap["level_change_at"] = w.LevelChangeAt
	w.fieldMap["total_deposit"] = w.TotalDeposit
	w.fieldMap["total_admin_transfer"] = w.TotalAdminTransfer
	w.fieldMap["total_admin_transfer_sub"] = w.TotalAdminTransferSub
	w.fieldMap["total_admin_transfer_add"] = w.TotalAdminTransferAdd
	w.fieldMap["total_bet"] = w.TotalBet
	w.fieldMap["total_valid_bet"] = w.TotalValidBet
	w.fieldMap["total_withdrawal"] = w.TotalWithdrawal
	w.fieldMap["withdrawal_num"] = w.WithdrawalNum
	w.fieldMap["deposit_num"] = w.DepositNum
	w.fieldMap["withdrawal_must_code"] = w.WithdrawalMustCode
	w.fieldMap["withdrawal_must_real_code"] = w.WithdrawalMustRealCode
	w.fieldMap["created_at"] = w.CreatedAt
	w.fieldMap["updated_at"] = w.UpdatedAt
}

func (w winUserExt) clone(db *gorm.DB) winUserExt {
	w.winUserExtDo.ReplaceConnPool(db.Statement.ConnPool)
	return w
}

func (w winUserExt) replaceDB(db *gorm.DB) winUserExt {
	w.winUserExtDo.ReplaceDB(db)
	return w
}

type winUserExtDo struct{ gen.DO }

func (w winUserExtDo) Debug() *winUserExtDo {
	return w.withDO(w.DO.Debug())
}

func (w winUserExtDo) WithContext(ctx context.Context) *winUserExtDo {
	return w.withDO(w.DO.WithContext(ctx))
}

func (w winUserExtDo) ReadDB() *winUserExtDo {
	return w.Clauses(dbresolver.Read)
}

func (w winUserExtDo) WriteDB() *winUserExtDo {
	return w.Clauses(dbresolver.Write)
}

func (w winUserExtDo) Session(config *gorm.Session) *winUserExtDo {
	return w.withDO(w.DO.Session(config))
}

func (w winUserExtDo) Clauses(conds ...clause.Expression) *winUserExtDo {
	return w.withDO(w.DO.Clauses(conds...))
}

func (w winUserExtDo) Returning(value interface{}, columns ...string) *winUserExtDo {
	return w.withDO(w.DO.Returning(value, columns...))
}

func (w winUserExtDo) Not(conds ...gen.Condition) *winUserExtDo {
	return w.withDO(w.DO.Not(conds...))
}

func (w winUserExtDo) Or(conds ...gen.Condition) *winUserExtDo {
	return w.withDO(w.DO.Or(conds...))
}

func (w winUserExtDo) Select(conds ...field.Expr) *winUserExtDo {
	return w.withDO(w.DO.Select(conds...))
}

func (w winUserExtDo) Where(conds ...gen.Condition) *winUserExtDo {
	return w.withDO(w.DO.Where(conds...))
}

func (w winUserExtDo) Order(conds ...field.Expr) *winUserExtDo {
	return w.withDO(w.DO.Order(conds...))
}

func (w winUserExtDo) Distinct(cols ...field.Expr) *winUserExtDo {
	return w.withDO(w.DO.Distinct(cols...))
}

func (w winUserExtDo) Omit(cols ...field.Expr) *winUserExtDo {
	return w.withDO(w.DO.Omit(cols...))
}

func (w winUserExtDo) Join(table schema.Tabler, on ...field.Expr) *winUserExtDo {
	return w.withDO(w.DO.Join(table, on...))
}

func (w winUserExtDo) LeftJoin(table schema.Tabler, on ...field.Expr) *winUserExtDo {
	return w.withDO(w.DO.LeftJoin(table, on...))
}

func (w winUserExtDo) RightJoin(table schema.Tabler, on ...field.Expr) *winUserExtDo {
	return w.withDO(w.DO.RightJoin(table, on...))
}

func (w winUserExtDo) Group(cols ...field.Expr) *winUserExtDo {
	return w.withDO(w.DO.Group(cols...))
}

func (w winUserExtDo) Having(conds ...gen.Condition) *winUserExtDo {
	return w.withDO(w.DO.Having(conds...))
}

func (w winUserExtDo) Limit(limit int) *winUserExtDo {
	return w.withDO(w.DO.Limit(limit))
}

func (w winUserExtDo) Offset(offset int) *winUserExtDo {
	return w.withDO(w.DO.Offset(offset))
}

func (w winUserExtDo) Scopes(funcs ...func(gen.Dao) gen.Dao) *winUserExtDo {
	return w.withDO(w.DO.Scopes(funcs...))
}

func (w winUserExtDo) Unscoped() *winUserExtDo {
	return w.withDO(w.DO.Unscoped())
}

func (w winUserExtDo) Create(values ...*model.WinUserExt) error {
	if len(values) == 0 {
		return nil
	}
	return w.DO.Create(values)
}

func (w winUserExtDo) CreateInBatches(values []*model.WinUserExt, batchSize int) error {
	return w.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (w winUserExtDo) Save(values ...*model.WinUserExt) error {
	if len(values) == 0 {
		return nil
	}
	return w.DO.Save(values)
}

func (w winUserExtDo) First() (*model.WinUserExt, error) {
	if result, err := w.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.WinUserExt), nil
	}
}

func (w winUserExtDo) Take() (*model.WinUserExt, error) {
	if result, err := w.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.WinUserExt), nil
	}
}

func (w winUserExtDo) Last() (*model.WinUserExt, error) {
	if result, err := w.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.WinUserExt), nil
	}
}

func (w winUserExtDo) Find() ([]*model.WinUserExt, error) {
	result, err := w.DO.Find()
	return result.([]*model.WinUserExt), err
}

func (w winUserExtDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.WinUserExt, err error) {
	buf := make([]*model.WinUserExt, 0, batchSize)
	err = w.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (w winUserExtDo) FindInBatches(result *[]*model.WinUserExt, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return w.DO.FindInBatches(result, batchSize, fc)
}

func (w winUserExtDo) Attrs(attrs ...field.AssignExpr) *winUserExtDo {
	return w.withDO(w.DO.Attrs(attrs...))
}

func (w winUserExtDo) Assign(attrs ...field.AssignExpr) *winUserExtDo {
	return w.withDO(w.DO.Assign(attrs...))
}

func (w winUserExtDo) Joins(fields ...field.RelationField) *winUserExtDo {
	for _, _f := range fields {
		w = *w.withDO(w.DO.Joins(_f))
	}
	return &w
}

func (w winUserExtDo) Preload(fields ...field.RelationField) *winUserExtDo {
	for _, _f := range fields {
		w = *w.withDO(w.DO.Preload(_f))
	}
	return &w
}

func (w winUserExtDo) FirstOrInit() (*model.WinUserExt, error) {
	if result, err := w.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.WinUserExt), nil
	}
}

func (w winUserExtDo) FirstOrCreate() (*model.WinUserExt, error) {
	if result, err := w.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.WinUserExt), nil
	}
}

func (w winUserExtDo) FindByPage(offset int, limit int) (result []*model.WinUserExt, count int64, err error) {
	result, err = w.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = w.Offset(-1).Limit(-1).Count()
	return
}

func (w winUserExtDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = w.Count()
	if err != nil {
		return
	}

	err = w.Offset(offset).Limit(limit).Scan(result)
	return
}

func (w winUserExtDo) Scan(result interface{}) (err error) {
	return w.DO.Scan(result)
}

func (w winUserExtDo) Delete(models ...*model.WinUserExt) (result gen.ResultInfo, err error) {
	return w.DO.Delete(models)
}

func (w *winUserExtDo) withDO(do gen.Dao) *winUserExtDo {
	w.DO = *do.(*gen.DO)
	return w
}
